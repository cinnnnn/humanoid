#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import socket
import struct
from threading import Thread, Lock, Event
from Queue import Queue, Empty as EmptyQueue

import jtrace.util

_DEFAULT_THREAD_JOIN_TIMEOUT_ = 0.02

CMD_PKT         = '0'
REPLY_PKT       = '1'
REPLY_PACKET_TYPE = 0x80
HANDSHAKE_MSG = 'JDWP-Handshake'

# python  struct pack format
# c    char string of length 1    1
# B    unsigned char    integer    1
# H    unsigned short    integer    2
# I    unsigned long    integer    4
# Q    unsigned long long    integer 8

class EOF(Exception):
    def __init__(self, inner=None):
        Exception.__init__(
            self, str(inner) if inner else "EOF"
        )

class HandshakeError(Exception):
    def __init__(self):
        Exception.__init__(
            self, 'handshake error, received message did not match'
        )

class ProtocolError(Exception):
    pass

def forward(pid, portno, dev=None):
    temp = str(portno)
    cmd = ('-s', dev) if dev else ()
    cmd += ('forward', 'tcp:' + temp, 'jdwp:%s' % pid)
    jtrace.util.adb(*cmd)
    return '127.0.0.1', portno, dev

def connect(addr, portno=None):
    if addr and portno:
        conn = socket.create_connection((addr, portno))
    else:
        conn = socket.socket(socket.AF_UNIX)
        conn.connect(addr)
    p = Connection(conn)
    p.start()
    return p

class Connection(Thread):
    def __init__(self, socket_conn):
        Thread.__init__(self)
        self.initialized = False
        self.next_id = 3
        self.bindqueue = Queue()
        self.reply_pkt_map = {}
        self.cmd_pkt_map = {}
        self.xmitlock = Lock()
        self.stop_flag = Event()
        self.socket_conn = socket_conn
        self.trace = False

    def do_read(self, amt):
        """
        Read data from the socket
        """
        req = amt
        buf = ''
        while req:
            pkt = self.socket_conn.recv(req)
            if not pkt: raise EOF()
            buf += pkt
            req -= len(pkt)
        if self.trace:
            print "===> RX:", repr(buf)
        return buf

    def do_write(self, data):
        """
        Write data to the socket
        """
        try:
            if self.trace:
                print "===> TX:", repr(data)
            self.socket_conn.sendall(data)
        except Exception as exc:
            raise EOF(exc)

    def read(self, sz):
        """
        Read data with size sz
        """
        if sz == 0:
            return ''
        pkt = self.do_read(sz)
        if not len(pkt):
            # raise exception if there is nothing to read
            raise EOF()
        return pkt

    def write_id_size(self):
        """
        Send the id size cmd to the VM
        """
        length = 11
        ident = 1
        flags  = 0
        cmd = 0x0107
        header = struct.pack('>IIBH', length, ident, flags, cmd)
        return self.do_write(header)

    def read_id_size(self):
        """
        Parse the read id size result
        """
        head = self.read_header()
        if head[0] != 20 + 11:
            raise ProtocolError('expected size of an idsize response')
        if head[2] != REPLY_PACKET_TYPE:
            raise ProtocolError('expected first server message to be a response')
        if head[1] != 1:
            raise ProtocolError('expected first server message to be 1')

        body = self.read(20)
        data = struct.unpack(">IIIII", body)
        self.sizes = list(data)
        setattr(self, "fieldIDSize", self.sizes[0])
        setattr(self, "methodIDSize", self.sizes[1])
        setattr(self, "objectIDSize", self.sizes[2])
        setattr(self, "threadIDSize", self.sizes[2])
        setattr(self, "referenceTypeIDSize", self.sizes[3])
        setattr(self, "frameIDSize", self.sizes[4])

        return None

    def read_handshake(self):
        """
        Read the jdwp handshake
        """
        data = self.read(len(HANDSHAKE_MSG))
        if data != HANDSHAKE_MSG:
            raise HandshakeError()

    def write_handshake(self):
        """
        Write the jdwp handshake
        """
        return self.do_write(HANDSHAKE_MSG)

    def read_header(self):
        """
        Read the header
        """
        header = self.read(11)
        data = struct.unpack(">IIBH", header)
        return data

    def process_data_from_vm(self):
        """
        Handle data from the VM, both the response from VM initated by the
        Debugger and VM's request initated by the VM
        """
        size, ident, flags, code = self.read_header()
        size -= 11
        data = self.read(size)
        try:
            # We process binds after receiving messages to prevent a race
            while True:
                # With False passed to bindqueue.get, it will trigger EmptyQueue exception
                self.set_bind(*self.bindqueue.get(False))
        except EmptyQueue:
            pass

        if flags == REPLY_PACKET_TYPE:
            # reply with flag 0x80
            self.process_reply_packet(ident, code, data)
        else:
            # request with falg 0x00
            self.process_command_packet(ident, code, data)

    def set_bind(self, qr, ident, chan):
        """
        Bind the queue for REPLY_PKT and CMD_PKT
        """
        if qr == REPLY_PKT:
            self.reply_pkt_map[ident] = chan
        elif qr == CMD_PKT:
            self.cmd_pkt_map[ident] = chan

    def process_command_packet(self, ident, code, data):
        """
        Handle command packet from VM
        """
        chan = self.cmd_pkt_map.get(code)
        if not chan:
            return
        # chan.get() will be woke up in vm.py Session.run
        return chan.put((ident, data))

    def process_reply_packet(self, ident, code, data):
        """
        Handle reply packet from VM
        """
        chan = self.reply_pkt_map.pop(ident, None)
        if not chan:
            return
        # chan.get() in request() will be woke up
        return chan.put((code, data))

    def set_vm_request_cb(self, code, chan):
        """
        In vm.py Session conn.hook(0x4064, Session.evtq) will be called so that
        Request initiated by VM: Event Command Set (64) Composite Command (100)
        will be handled in proto.py
        """
        with self.xmitlock:
            self.bindqueue.put((CMD_PKT, code, chan))

    def acquire_ident(self):
        """
        Get a request id
        """
        ident = self.next_id
        self.next_id += 2
        return ident

    def write_request_data(self, ident, flags, code, body):
        """
        Write the request data to jdwp
        """
        size = len(body) + 11
        header = struct.pack(">IIcH", size, ident, flags, code)
        self.do_write(header + body)

    def request(self, code, data='', timeout=None):
        """
        send a request, then waits for a response; returns response
        conn.request returns code and buf
        """
        # create a new queue to get the response of this request
        queue = Queue()
        with self.xmitlock:
            ident = self.acquire_ident()
            self.bindqueue.put((REPLY_PKT, ident, queue))
            self.write_request_data(ident, chr(0x0), code, data)

        try:
            return queue.get(1, timeout)
        except EmptyQueue:
            return None, None

    def start(self):
        """
        Start the jdwp processing
        """
        self.daemon = True
        if not self.initialized:
            self.write_handshake()
            self.read_handshake()
            self.write_id_size()
            self.read_id_size()
            self.initialized = True
            Thread.start(self)
        return None

    def run(self):
        """
        Thread function for jdwp
        """
        try:
            while not self.stop_flag.is_set():
                self.process_data_from_vm()
        except EOF:
            print "process_data_from_vm done!"
            # os._exit(0)

    def stop(self):
        """
        Stop the jdwp processing
        TODO: join before set close flag
        """
        self.stop_flag.set()
        self.join(timeout=_DEFAULT_THREAD_JOIN_TIMEOUT_)
        try:
            self.socket_conn.shutdown(socket.SHUT_RDWR)
            self.socket_conn.close()
        except Exception as e:
            print(e)

    def close(self):
        """
        close the socket connection
        """
        try:
            self.socket_conn.shutdown(socket.SHUT_RDWR)
            self.socket_conn.close()
        except Exception, e:
            pass
